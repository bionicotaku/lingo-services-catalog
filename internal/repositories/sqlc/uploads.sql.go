// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: uploads.sql

package catalogsql

import (
	"context"

	uuid "github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const getUploadByObject = `-- name: GetUploadByObject :one
SELECT video_id, user_id, bucket, object_name, content_type, expected_size, size_bytes, content_md5, title, description, signed_url, signed_url_expires_at, status, gcs_generation, gcs_etag, md5_hash, crc32c, error_code, error_message, created_at, updated_at
FROM catalog.uploads
WHERE bucket = $1
  AND object_name = $2
LIMIT 1
`

type GetUploadByObjectParams struct {
	Bucket     string `json:"bucket"`
	ObjectName string `json:"object_name"`
}

func (q *Queries) GetUploadByObject(ctx context.Context, arg GetUploadByObjectParams) (CatalogUpload, error) {
	row := q.db.QueryRow(ctx, getUploadByObject, arg.Bucket, arg.ObjectName)
	var i CatalogUpload
	err := row.Scan(
		&i.VideoID,
		&i.UserID,
		&i.Bucket,
		&i.ObjectName,
		&i.ContentType,
		&i.ExpectedSize,
		&i.SizeBytes,
		&i.ContentMd5,
		&i.Title,
		&i.Description,
		&i.SignedUrl,
		&i.SignedUrlExpiresAt,
		&i.Status,
		&i.GcsGeneration,
		&i.GcsEtag,
		&i.Md5Hash,
		&i.Crc32c,
		&i.ErrorCode,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUploadByUserMd5 = `-- name: GetUploadByUserMd5 :one
SELECT video_id, user_id, bucket, object_name, content_type, expected_size, size_bytes, content_md5, title, description, signed_url, signed_url_expires_at, status, gcs_generation, gcs_etag, md5_hash, crc32c, error_code, error_message, created_at, updated_at
FROM catalog.uploads
WHERE user_id = $1
  AND content_md5 = $2
LIMIT 1
`

type GetUploadByUserMd5Params struct {
	UserID     uuid.UUID `json:"user_id"`
	ContentMd5 string    `json:"content_md5"`
}

func (q *Queries) GetUploadByUserMd5(ctx context.Context, arg GetUploadByUserMd5Params) (CatalogUpload, error) {
	row := q.db.QueryRow(ctx, getUploadByUserMd5, arg.UserID, arg.ContentMd5)
	var i CatalogUpload
	err := row.Scan(
		&i.VideoID,
		&i.UserID,
		&i.Bucket,
		&i.ObjectName,
		&i.ContentType,
		&i.ExpectedSize,
		&i.SizeBytes,
		&i.ContentMd5,
		&i.Title,
		&i.Description,
		&i.SignedUrl,
		&i.SignedUrlExpiresAt,
		&i.Status,
		&i.GcsGeneration,
		&i.GcsEtag,
		&i.Md5Hash,
		&i.Crc32c,
		&i.ErrorCode,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUploadByVideoID = `-- name: GetUploadByVideoID :one
SELECT video_id, user_id, bucket, object_name, content_type, expected_size, size_bytes, content_md5, title, description, signed_url, signed_url_expires_at, status, gcs_generation, gcs_etag, md5_hash, crc32c, error_code, error_message, created_at, updated_at
FROM catalog.uploads
WHERE video_id = $1
LIMIT 1
`

func (q *Queries) GetUploadByVideoID(ctx context.Context, videoID uuid.UUID) (CatalogUpload, error) {
	row := q.db.QueryRow(ctx, getUploadByVideoID, videoID)
	var i CatalogUpload
	err := row.Scan(
		&i.VideoID,
		&i.UserID,
		&i.Bucket,
		&i.ObjectName,
		&i.ContentType,
		&i.ExpectedSize,
		&i.SizeBytes,
		&i.ContentMd5,
		&i.Title,
		&i.Description,
		&i.SignedUrl,
		&i.SignedUrlExpiresAt,
		&i.Status,
		&i.GcsGeneration,
		&i.GcsEtag,
		&i.Md5Hash,
		&i.Crc32c,
		&i.ErrorCode,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listExpiredUploads = `-- name: ListExpiredUploads :many
SELECT video_id, user_id, bucket, object_name, content_type, expected_size, size_bytes, content_md5, title, description, signed_url, signed_url_expires_at, status, gcs_generation, gcs_etag, md5_hash, crc32c, error_code, error_message, created_at, updated_at
FROM catalog.uploads
WHERE status = 'uploading'
  AND signed_url_expires_at IS NOT NULL
  AND signed_url_expires_at < $1
ORDER BY signed_url_expires_at ASC
LIMIT $2
`

type ListExpiredUploadsParams struct {
	Cutoff pgtype.Timestamptz `json:"cutoff"`
	Limit  int32              `json:"limit"`
}

func (q *Queries) ListExpiredUploads(ctx context.Context, arg ListExpiredUploadsParams) ([]CatalogUpload, error) {
	rows, err := q.db.Query(ctx, listExpiredUploads, arg.Cutoff, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CatalogUpload{}
	for rows.Next() {
		var i CatalogUpload
		if err := rows.Scan(
			&i.VideoID,
			&i.UserID,
			&i.Bucket,
			&i.ObjectName,
			&i.ContentType,
			&i.ExpectedSize,
			&i.SizeBytes,
			&i.ContentMd5,
			&i.Title,
			&i.Description,
			&i.SignedUrl,
			&i.SignedUrlExpiresAt,
			&i.Status,
			&i.GcsGeneration,
			&i.GcsEtag,
			&i.Md5Hash,
			&i.Crc32c,
			&i.ErrorCode,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markUploadCompleted = `-- name: MarkUploadCompleted :one
UPDATE catalog.uploads
SET status = 'completed',
    size_bytes = $1,
    md5_hash = $2,
    crc32c = $3,
    gcs_generation = $4,
    gcs_etag = $5,
    content_type = COALESCE($6, content_type),
    signed_url = NULL,
    signed_url_expires_at = NULL,
    error_code = NULL,
    error_message = NULL,
    updated_at = now()
WHERE video_id = $7
RETURNING video_id, user_id, bucket, object_name, content_type, expected_size, size_bytes, content_md5, title, description, signed_url, signed_url_expires_at, status, gcs_generation, gcs_etag, md5_hash, crc32c, error_code, error_message, created_at, updated_at
`

type MarkUploadCompletedParams struct {
	SizeBytes     int64       `json:"size_bytes"`
	Md5Hash       pgtype.Text `json:"md5_hash"`
	Crc32c        pgtype.Text `json:"crc32c"`
	GcsGeneration pgtype.Text `json:"gcs_generation"`
	GcsEtag       pgtype.Text `json:"gcs_etag"`
	ContentType   pgtype.Text `json:"content_type"`
	VideoID       uuid.UUID   `json:"video_id"`
}

func (q *Queries) MarkUploadCompleted(ctx context.Context, arg MarkUploadCompletedParams) (CatalogUpload, error) {
	row := q.db.QueryRow(ctx, markUploadCompleted,
		arg.SizeBytes,
		arg.Md5Hash,
		arg.Crc32c,
		arg.GcsGeneration,
		arg.GcsEtag,
		arg.ContentType,
		arg.VideoID,
	)
	var i CatalogUpload
	err := row.Scan(
		&i.VideoID,
		&i.UserID,
		&i.Bucket,
		&i.ObjectName,
		&i.ContentType,
		&i.ExpectedSize,
		&i.SizeBytes,
		&i.ContentMd5,
		&i.Title,
		&i.Description,
		&i.SignedUrl,
		&i.SignedUrlExpiresAt,
		&i.Status,
		&i.GcsGeneration,
		&i.GcsEtag,
		&i.Md5Hash,
		&i.Crc32c,
		&i.ErrorCode,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const markUploadFailed = `-- name: MarkUploadFailed :one
UPDATE catalog.uploads
SET status = 'failed',
    error_code = $1,
    error_message = $2,
    updated_at = now()
WHERE video_id = $3
RETURNING video_id, user_id, bucket, object_name, content_type, expected_size, size_bytes, content_md5, title, description, signed_url, signed_url_expires_at, status, gcs_generation, gcs_etag, md5_hash, crc32c, error_code, error_message, created_at, updated_at
`

type MarkUploadFailedParams struct {
	ErrorCode    pgtype.Text `json:"error_code"`
	ErrorMessage pgtype.Text `json:"error_message"`
	VideoID      uuid.UUID   `json:"video_id"`
}

func (q *Queries) MarkUploadFailed(ctx context.Context, arg MarkUploadFailedParams) (CatalogUpload, error) {
	row := q.db.QueryRow(ctx, markUploadFailed, arg.ErrorCode, arg.ErrorMessage, arg.VideoID)
	var i CatalogUpload
	err := row.Scan(
		&i.VideoID,
		&i.UserID,
		&i.Bucket,
		&i.ObjectName,
		&i.ContentType,
		&i.ExpectedSize,
		&i.SizeBytes,
		&i.ContentMd5,
		&i.Title,
		&i.Description,
		&i.SignedUrl,
		&i.SignedUrlExpiresAt,
		&i.Status,
		&i.GcsGeneration,
		&i.GcsEtag,
		&i.Md5Hash,
		&i.Crc32c,
		&i.ErrorCode,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertUpload = `-- name: UpsertUpload :one
WITH upsert AS (
  INSERT INTO catalog.uploads AS u (
    video_id,
    user_id,
    bucket,
    object_name,
    content_type,
    expected_size,
    content_md5,
    title,
    description,
    signed_url,
    signed_url_expires_at,
    status
  )
  VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10,
    $11,
    $12
  )
  ON CONFLICT (user_id, content_md5)
  DO UPDATE
  SET bucket = EXCLUDED.bucket,
      object_name = EXCLUDED.object_name,
      content_type = EXCLUDED.content_type,
      expected_size = EXCLUDED.expected_size,
      title = EXCLUDED.title,
      description = EXCLUDED.description,
      signed_url = EXCLUDED.signed_url,
      signed_url_expires_at = EXCLUDED.signed_url_expires_at,
      status = CASE
        WHEN catalog.uploads.status = 'completed' THEN catalog.uploads.status
        ELSE EXCLUDED.status
      END,
      updated_at = now()
  RETURNING u.video_id,
            u.user_id,
            u.bucket,
            u.object_name,
            u.content_type,
            u.expected_size,
            u.size_bytes,
            u.content_md5,
            u.title,
            u.description,
            u.signed_url,
            u.signed_url_expires_at,
            u.status,
            u.gcs_generation,
            u.gcs_etag,
            u.md5_hash,
            u.crc32c,
            u.error_code,
            u.error_message,
            u.created_at,
            u.updated_at,
            (xmax = 0)::bool AS inserted
)
SELECT video_id, user_id, bucket, object_name, content_type, expected_size, size_bytes, content_md5, title, description, signed_url, signed_url_expires_at, status, gcs_generation, gcs_etag, md5_hash, crc32c, error_code, error_message, created_at, updated_at, inserted FROM upsert
`

type UpsertUploadParams struct {
	VideoID            uuid.UUID          `json:"video_id"`
	UserID             uuid.UUID          `json:"user_id"`
	Bucket             string             `json:"bucket"`
	ObjectName         string             `json:"object_name"`
	ContentType        pgtype.Text        `json:"content_type"`
	ExpectedSize       int64              `json:"expected_size"`
	ContentMd5         string             `json:"content_md5"`
	Title              string             `json:"title"`
	Description        string             `json:"description"`
	SignedUrl          pgtype.Text        `json:"signed_url"`
	SignedUrlExpiresAt pgtype.Timestamptz `json:"signed_url_expires_at"`
	Status             string             `json:"status"`
}

type UpsertUploadRow struct {
	VideoID            uuid.UUID          `json:"video_id"`
	UserID             uuid.UUID          `json:"user_id"`
	Bucket             string             `json:"bucket"`
	ObjectName         string             `json:"object_name"`
	ContentType        pgtype.Text        `json:"content_type"`
	ExpectedSize       int64              `json:"expected_size"`
	SizeBytes          int64              `json:"size_bytes"`
	ContentMd5         string             `json:"content_md5"`
	Title              string             `json:"title"`
	Description        string             `json:"description"`
	SignedUrl          pgtype.Text        `json:"signed_url"`
	SignedUrlExpiresAt pgtype.Timestamptz `json:"signed_url_expires_at"`
	Status             string             `json:"status"`
	GcsGeneration      pgtype.Text        `json:"gcs_generation"`
	GcsEtag            pgtype.Text        `json:"gcs_etag"`
	Md5Hash            pgtype.Text        `json:"md5_hash"`
	Crc32c             pgtype.Text        `json:"crc32c"`
	ErrorCode          pgtype.Text        `json:"error_code"`
	ErrorMessage       pgtype.Text        `json:"error_message"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
	Inserted           bool               `json:"inserted"`
}

func (q *Queries) UpsertUpload(ctx context.Context, arg UpsertUploadParams) (UpsertUploadRow, error) {
	row := q.db.QueryRow(ctx, upsertUpload,
		arg.VideoID,
		arg.UserID,
		arg.Bucket,
		arg.ObjectName,
		arg.ContentType,
		arg.ExpectedSize,
		arg.ContentMd5,
		arg.Title,
		arg.Description,
		arg.SignedUrl,
		arg.SignedUrlExpiresAt,
		arg.Status,
	)
	var i UpsertUploadRow
	err := row.Scan(
		&i.VideoID,
		&i.UserID,
		&i.Bucket,
		&i.ObjectName,
		&i.ContentType,
		&i.ExpectedSize,
		&i.SizeBytes,
		&i.ContentMd5,
		&i.Title,
		&i.Description,
		&i.SignedUrl,
		&i.SignedUrlExpiresAt,
		&i.Status,
		&i.GcsGeneration,
		&i.GcsEtag,
		&i.Md5Hash,
		&i.Crc32c,
		&i.ErrorCode,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Inserted,
	)
	return i, err
}
