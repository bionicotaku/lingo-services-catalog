// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: engagement_stats.sql

package catalogsql

import (
	"context"

	uuid "github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const getVideoEngagementStats = `-- name: GetVideoEngagementStats :one
SELECT
    video_id,
    like_count,
    bookmark_count,
    watch_count,
    unique_watchers,
    first_watch_at,
    last_watch_at,
    updated_at
FROM catalog.video_engagement_stats_projection
WHERE video_id = $1
`

// 统计投影读取
func (q *Queries) GetVideoEngagementStats(ctx context.Context, videoID uuid.UUID) (CatalogVideoEngagementStatsProjection, error) {
	row := q.db.QueryRow(ctx, getVideoEngagementStats, videoID)
	var i CatalogVideoEngagementStatsProjection
	err := row.Scan(
		&i.VideoID,
		&i.LikeCount,
		&i.BookmarkCount,
		&i.WatchCount,
		&i.UniqueWatchers,
		&i.FirstWatchAt,
		&i.LastWatchAt,
		&i.UpdatedAt,
	)
	return i, err
}

const incrementVideoEngagementStats = `-- name: IncrementVideoEngagementStats :one
INSERT INTO catalog.video_engagement_stats_projection (
    video_id,
    like_count,
    bookmark_count,
    watch_count,
    unique_watchers,
    first_watch_at,
    last_watch_at,
    updated_at
) VALUES (
    $1,
    GREATEST($2::bigint, 0),
    GREATEST($3::bigint, 0),
    GREATEST($4::bigint, 0),
    GREATEST($5::bigint, 0),
    $6,
    $7,
    now()
)
ON CONFLICT (video_id) DO UPDATE
SET
    like_count = GREATEST(0, catalog.video_engagement_stats_projection.like_count + $2::bigint),
    bookmark_count = GREATEST(0, catalog.video_engagement_stats_projection.bookmark_count + $3::bigint),
    watch_count = GREATEST(0, catalog.video_engagement_stats_projection.watch_count + $4::bigint),
    unique_watchers = GREATEST(0, catalog.video_engagement_stats_projection.unique_watchers + $5::bigint),
    first_watch_at = CASE
        WHEN $6 IS NULL THEN catalog.video_engagement_stats_projection.first_watch_at
        WHEN catalog.video_engagement_stats_projection.first_watch_at IS NULL THEN $6
        ELSE LEAST(catalog.video_engagement_stats_projection.first_watch_at, $6)
    END,
    last_watch_at = CASE
        WHEN $7 IS NULL THEN catalog.video_engagement_stats_projection.last_watch_at
        WHEN catalog.video_engagement_stats_projection.last_watch_at IS NULL THEN $7
        ELSE GREATEST(catalog.video_engagement_stats_projection.last_watch_at, $7)
    END,
    updated_at = now()
RETURNING
    video_id,
    like_count,
    bookmark_count,
    watch_count,
    unique_watchers,
    first_watch_at,
    last_watch_at,
    updated_at
`

type IncrementVideoEngagementStatsParams struct {
	VideoID            uuid.UUID          `json:"video_id"`
	LikeDelta          int64              `json:"like_delta"`
	BookmarkDelta      int64              `json:"bookmark_delta"`
	WatchDelta         int64              `json:"watch_delta"`
	UniqueWatcherDelta int64              `json:"unique_watcher_delta"`
	FirstWatchAt       pgtype.Timestamptz `json:"first_watch_at"`
	LastWatchAt        pgtype.Timestamptz `json:"last_watch_at"`
}

// 增量更新统计计数
func (q *Queries) IncrementVideoEngagementStats(ctx context.Context, arg IncrementVideoEngagementStatsParams) (CatalogVideoEngagementStatsProjection, error) {
	row := q.db.QueryRow(ctx, incrementVideoEngagementStats,
		arg.VideoID,
		arg.LikeDelta,
		arg.BookmarkDelta,
		arg.WatchDelta,
		arg.UniqueWatcherDelta,
		arg.FirstWatchAt,
		arg.LastWatchAt,
	)
	var i CatalogVideoEngagementStatsProjection
	err := row.Scan(
		&i.VideoID,
		&i.LikeCount,
		&i.BookmarkCount,
		&i.WatchCount,
		&i.UniqueWatchers,
		&i.FirstWatchAt,
		&i.LastWatchAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertVideoWatcher = `-- name: UpsertVideoWatcher :one
INSERT INTO catalog.video_engagement_watchers (
    video_id,
    user_id,
    first_watched_at,
    last_watched_at
) VALUES (
    $1,
    $2,
    $3,
    $3
)
ON CONFLICT (video_id, user_id) DO UPDATE
SET last_watched_at = GREATEST(catalog.video_engagement_watchers.last_watched_at, EXCLUDED.last_watched_at)
RETURNING
    video_id,
    user_id,
    first_watched_at,
    last_watched_at,
    (xmax = 0) AS inserted
`

type UpsertVideoWatcherParams struct {
	VideoID   uuid.UUID          `json:"video_id"`
	UserID    uuid.UUID          `json:"user_id"`
	WatchTime pgtype.Timestamptz `json:"watch_time"`
}

type UpsertVideoWatcherRow struct {
	VideoID        uuid.UUID          `json:"video_id"`
	UserID         uuid.UUID          `json:"user_id"`
	FirstWatchedAt pgtype.Timestamptz `json:"first_watched_at"`
	LastWatchedAt  pgtype.Timestamptz `json:"last_watched_at"`
	Inserted       bool               `json:"inserted"`
}

// 记录唯一观看者
func (q *Queries) UpsertVideoWatcher(ctx context.Context, arg UpsertVideoWatcherParams) (UpsertVideoWatcherRow, error) {
	row := q.db.QueryRow(ctx, upsertVideoWatcher, arg.VideoID, arg.UserID, arg.WatchTime)
	var i UpsertVideoWatcherRow
	err := row.Scan(
		&i.VideoID,
		&i.UserID,
		&i.FirstWatchedAt,
		&i.LastWatchedAt,
		&i.Inserted,
	)
	return i, err
}
